<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rksm2329 Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="RKSM2329 BLOG">
<meta property="og:type" content="website">
<meta property="og:title" content="rksm2329 Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="rksm2329 Blog">
<meta property="og:description" content="RKSM2329 BLOG">
<meta property="og:locale">
<meta property="article:author" content="rksm2329">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="rksm2329 Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rksm2329 Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello! Welcome!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-diffrence" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/22/diffrence/" class="article-date">
  <time class="dt-published" datetime="2023-11-22T13:59:57.000Z" itemprop="datePublished">2023-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/22/diffrence/">差分</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>给定长度为 $n$ 的序列 $a_{1},a_{2},\dots a_{n}$，它的差分序列定义为相邻两项之差，即 $a_{1},a_{2}-a_{1},a_{3}-a_{2}\dots a_{n}-a_{n-1}$</p>
<p>差分序列的第 $i$ 项为 $d_{i}&#x3D;a_{i}-a_{i-1}$，其中 $a_{0}&#x3D;0$</p>
<p>可以发现，对差分序列做<strong>前缀和</strong>，可以还原出原数列。</p>
<h2 id="一维差分-区间修改"><a href="#一维差分-区间修改" class="headerlink" title="一维差分 区间修改"></a>一维差分 区间修改</h2><p>如果对原序列区间 $[l,r]$ 的元素加上 $v$，实际上对应了差分序列两个元素的修改。</p>
<p>也就是说，区间内的每个元素的加法操作，可以直接变成差分序列上两个元素的修改</p>
<p>所有操作做完后，对差分序列做前缀和即可还原原序列。</p>
<h3 id="例题：区间修改"><a href="#例题：区间修改" class="headerlink" title="例题：区间修改"></a>例题：区间修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, l, r, c, a[MAXN], d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    d[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    d[l] += c;</span><br><span class="line">    d[r + <span class="number">1</span>] -= c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    d[i] = d[i - <span class="number">1</span>] + d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; d[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先直接做差分，然后输入 $l,r,c$，修改之后，就直接做前缀和输出了。</p>
<h2 id="二维差分-矩阵修改"><a href="#二维差分-矩阵修改" class="headerlink" title="二维差分 矩阵修改"></a>二维差分 矩阵修改</h2><p>暴力修改：$O(n_{} ^ {2})$</p>
<p>对列差分后的矩阵做修改：$O(n)$</p>
<p>逐维差分，对先列差分后行差分的矩阵做修改：$O(1)$</p>
<h3 id="还原原数组"><a href="#还原原数组" class="headerlink" title="还原原数组"></a>还原原数组</h3><p>做二维前缀和即可，$O(n_{} ^ {2})$</p>
<h3 id="示例二位数组"><a href="#示例二位数组" class="headerlink" title="示例二位数组"></a>示例二位数组</h3><p>原图（表1）：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>列差分后（表2）：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>做列前缀和还原</strong></p>
<p>再行差分（表3）：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>做行前缀和，再做列前缀和还原</strong></p>
<p>原数组直接做行差分（表4）：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>做行前缀和还原</strong></p>
<p>上4个表的顺序：</p>
<p>表1 $\to$ 表2 $\to$ 表3</p>
<p>表1 $\to$ 表4</p>
<h3 id="例题：矩阵修改"><a href="#例题：矩阵修改" class="headerlink" title="例题：矩阵修改"></a>例题：矩阵修改</h3><p>方法1：原图直接做列差分，还原做列差分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d[<span class="number">1010</span>][<span class="number">1010</span>], cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y1; j &lt;= y2; j++) &#123; <span class="comment">//列差分</span></span><br><span class="line">      d[x1][j]++;</span><br><span class="line">      d[x2 + <span class="number">1</span>][j]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1010</span>; i++) &#123; <span class="comment">//列前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1010</span>; j++) &#123;</span><br><span class="line">      d[i][j] = d[i][j] + d[i - <span class="number">1</span>][j];</span><br><span class="line">      cnt[d[i][j]]++; <span class="comment">//统计数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; cnt[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2：原图直接做行差分，还原做行差分和列差分，<strong>可以交换顺序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d[<span class="number">1010</span>][<span class="number">1010</span>], cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x1, y1, x2, y2; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    d[x1][y1]++, d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>]++;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y1]--, d[x1][y2 + <span class="number">1</span>]--;</span><br><span class="line">    <span class="comment">//行差分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1010</span>; i++) &#123; <span class="comment">//行前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1010</span>; j++) &#123;</span><br><span class="line">      d[i][j] = d[i][j] + d[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1010</span>; i++) &#123; <span class="comment">//列前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1010</span>; j++) &#123;</span><br><span class="line">      d[i][j] = d[i][j] + d[i][j - <span class="number">1</span>];</span><br><span class="line">      cnt[d[i][j]]++; <span class="comment">//统计数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; cnt[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法3，原图直接做行差分，做行前缀和还原</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d[<span class="number">1010</span>][<span class="number">1010</span>], cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y1; j &lt;= y2; j++) &#123;</span><br><span class="line">      d[x1][j]++;</span><br><span class="line">      d[x2 + <span class="number">1</span>][j]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1010</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1010</span>; j++) &#123;</span><br><span class="line">      d[i][j] = d[i][j] + d[i - <span class="number">1</span>][j];</span><br><span class="line">      cnt[d[i][j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; cnt[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/22/diffrence/" data-id="clr6cevbw00095shq3q69egky" data-title="差分" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">算法学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-heap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/22/heap/" class="article-date">
  <time class="dt-published" datetime="2023-11-22T13:54:51.000Z" itemprop="datePublished">2023-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/22/heap/">堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是⼀种⽀持动态快速查询最值的数据结构，⽀持以下操作：</p>
<ul>
<li><p>⾼效插⼊元素。</p>
</li>
<li><p>⾼效查询、删除最值。</p>
</li>
<li><p>⾼效修改指定元素、删除指定元素。</p>
</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>平时说的堆通常就指<strong>二叉堆</strong>,二叉堆是一种完全二叉树,它具有下面的性质:</p>
<blockquote>
<p>如果堆为<strong>小根堆</strong></p>
<ul>
<li>父节点的值不大于两个儿子的值</li>
</ul>
<p>如果堆为<strong>大根堆</strong></p>
<ul>
<li>父结点的值不小于两个儿子的值</li>
</ul>
</blockquote>
<p>堆的根结点⼜被称为堆顶，⼩根堆的堆顶元素是堆中最⼩的元素，大根堆就反着来。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>因为它是完全二叉树，所以可以直接用数组存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heap[MAXN], len;</span><br></pre></td></tr></table></figure>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>一个容器，最先要考虑的是<strong>增、删、改、查</strong>四个操作。</p>
<p>当对堆进行上面的操作的时候，可能会破坏堆的性质，也可能让堆不是完全二叉树，<strong>要考虑如何处理</strong>。</p>
<p>可以用两种操作来维护堆的性质：上浮、下沉，仅适用于小根堆，大根堆两个操作相反。</p>
<h3 id="上浮"><a href="#上浮" class="headerlink" title="上浮"></a>上浮</h3><p>当修改了堆中的某一个元素的时候，如果这个元素变小了：</p>
<ul>
<li><p>如果这个结点有父亲结点，并且值比父亲更小，那么交换当前结点与父亲节点的值，继续执行操作。</p>
</li>
<li><p>否则，停止操作。</p>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 上浮</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x, j = i / <span class="number">2</span>; j &gt;= <span class="number">1</span> &amp;&amp; heap[i] &lt; heap[j]; i = j, j = i / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[i], heap[j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下沉"><a href="#下沉" class="headerlink" title="下沉"></a>下沉</h3><p>当修改了堆中的某个元素的时候，如果这个元素变大了：</p>
<ul>
<li>如果这个结点有儿子结点，并且值比<strong>较小的儿子</strong>更大，那么交换当前结点与较小的儿子结点的值，继续执行操作</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">son</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 返回较小的儿子</span></span><br><span class="line">  <span class="type">int</span> i = x * <span class="number">2</span>, j = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> i + (j &lt;= n &amp;&amp; heap[i] &gt; heap[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 下沉</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x, j = <span class="built_in">son</span>(i); j &lt;= n &amp;&amp; heap[i] &gt; heap[j]; i = j, j = <span class="built_in">son</span>(i)) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[i], heap[j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询最值"><a href="#查询最值" class="headerlink" title="查询最值"></a>查询最值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="comment">// 查询最值</span></span><br><span class="line">  <span class="keyword">return</span> heap[<span class="number">1</span>]; <span class="comment">// 小根堆则为最小值，大根堆则为最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>可以在堆的尾部增加一个结点，保证堆仍然是一棵完全二叉树，然后上浮。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  heap[++n] = x;</span><br><span class="line">  <span class="built_in">up</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除最值"><a href="#删除最值" class="headerlink" title="删除最值"></a>删除最值</h3><p>如果直接删除堆顶，会使堆分裂为两个堆，⽽删除堆尾元素不需要维护。可以将堆顶和堆尾元素进⾏交换，然后删除堆尾元素，保证堆仍然是⼀棵完全⼆叉树。 如果交换后的堆顶不满⾜堆的性质，就下沉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[n--]);</span><br><span class="line">  <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><code>priority_queue</code></h2><p><code>priority_queue</code>，即优先队列，就是 C++ 已经弄好的堆，比赛时常用这个容器代替堆。</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要 3 个参数：Typename数据类型名，Container底层容器，Compare比较器</span></span><br><span class="line"><span class="comment">// 底层容器和比较器为可选参数</span></span><br><span class="line"><span class="comment">// 不指定底层容器和比较器时，默认为 vector&lt;Typename&gt; 和 less&lt;Typename&gt;（也就是大根堆）</span></span><br><span class="line">priority_queue&lt;Typename, [Container], [Compare])&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line"><span class="comment">// 定义了一个类型为 int，底层容器为 vector&lt;int&gt;，比较器为 less&lt;int&gt; 的优先队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q2;</span><br><span class="line"><span class="comment">// 定义了一个类型为 int，底层容器为 vector&lt;int&gt;，比较器为 greater&lt;int&gt; 的优先队列</span></span><br><span class="line"><span class="comment">// 需要引入头文件 &lt;functional&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// less 中文为较小的，但实际上是大数靠前的比较器，greater 为较大的，实际上是小数靠前的比较器。</span></span><br></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>$N$ 为堆内元素个数。</p>
<ul>
<li><p><code>top()</code> 访问堆顶，$O(1)$</p>
</li>
<li><p><code>empty()</code> 判断是否为空，$O(1)$</p>
</li>
<li><p><code>size()</code> 元素个数，$O(1)$</p>
</li>
<li><p><code>push(x)</code> 插入 $x$，$O(\log N)$</p>
</li>
<li><p><code>pop()</code> 弹出堆顶，$O(\log N)$</p>
</li>
<li><p>注意：没有 <code>clear()</code> 函数，清空需要不断 <code>pop()</code></p>
</li>
</ul>
<h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><p>对于结构体类型，我们需要定义其⽐较规则才能⽤优先队列维护该类型元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法-1：定义比较器函数对象"><a href="#方法-1：定义比较器函数对象" class="headerlink" title="方法 1：定义比较器函数对象"></a>方法 1：定义比较器函数对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node &amp;i, <span class="type">const</span> Node &amp;j)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 函数尾的 const 表示该函数不能对所在类的成员进⾏修改</span></span><br><span class="line">		<span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq; <span class="comment">// 定义了⼀个 x 为关键字的⼤根堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-2：重载运算符"><a href="#方法-2：重载运算符" class="headerlink" title="方法 2：重载运算符"></a>方法 2：重载运算符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;i, <span class="type">const</span> Node &amp;j) &#123;</span><br><span class="line">	<span class="keyword">return</span> i.x &gt; j.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 定义了⼀个 x 为关键字的⼩根堆</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, id;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;i) <span class="type">const</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> x &gt; i.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 定义了⼀个 x 为关键字的⼩根堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-3：使⽤-lambda-表达式（需要-C-11-及以上标准）"><a href="#方法-3：使⽤-lambda-表达式（需要-C-11-及以上标准）" class="headerlink" title="方法 3：使⽤ lambda 表达式（需要 C++11 及以上标准）"></a>方法 3：使⽤ lambda 表达式（需要 C++11 及以上标准）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Node &amp;i, <span class="type">const</span> Node &amp;j) &#123;</span><br><span class="line">	<span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, <span class="keyword">decltype</span>(cmp)) pq; // x 为关键字的⼤根堆</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1; <span class="comment">// ⼤根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; pq2; <span class="comment">// 小根堆</span></span><br><span class="line">pq1.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">pq1.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; pq1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 2</span></span><br><span class="line">pq1.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; pq1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">pq2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">pq2.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; pq2.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">pq2.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; pq2.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b, c; <span class="comment">// 三科的成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student &amp;i, <span class="type">const</span> Student &amp;j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i.a != j.a) &#123;</span><br><span class="line">      <span class="keyword">return</span> i.a &lt; j.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i.b != j.b) &#123;</span><br><span class="line">      <span class="keyword">return</span> i.b &lt; j.b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.c &lt; j.c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Student, vector&lt;Student&gt;, cmp&gt; pq; <span class="comment">// 按语数外从⾼到低排</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  pq.<span class="built_in">push</span>(&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">90</span>&#125;);</span><br><span class="line">  pq.<span class="built_in">push</span>(&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;);</span><br><span class="line">  pq.<span class="built_in">push</span>(&#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">100</span>&#125;);</span><br><span class="line">  pq.<span class="built_in">push</span>(&#123;<span class="number">90</span>, <span class="number">100</span>, <span class="number">100</span>&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    Student x = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; x.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P1090-NOIP2004-提高组-合并果子"><a href="#P1090-NOIP2004-提高组-合并果子" class="headerlink" title="P1090 [NOIP2004 提高组] 合并果子"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP2004 提高组] 合并果子</a></h3><p>贪⼼，每次选出数⽬最⼩的两堆进⾏合并即可。暴⼒模拟是 $O(n^2)$，可以⽤优先队列优化⾄ $O(n \log n)$。如果把合并过程建树，那么题⽬所要求的的答案就是 $\sum \limits_{i &#x3D; 1}^{n} a_id_i$，$a_i$ 为数⽬，$d_i$ 为 在树中的深度，显然 $d_i$ ⼤的叶⼦结点 $a_i$ ⼩的两堆进⾏合并。<br>尽可能⼩，因此每次选出数⽬最⼩的两堆进⾏合并。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    pq.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (pq.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> y = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    ans += x + y;</span><br><span class="line">    pq.<span class="built_in">push</span>(x + y);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1631-序列合并"><a href="#P1631-序列合并" class="headerlink" title="P1631 序列合并"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1631">P1631 序列合并</a></h3><p>堆优化。</p>
<p>如果暴⼒记录所有和，再加上排序，时间复杂度⾼达 $O(n^2 \log n)$。</p>
<p>我们可以先对 $n$ 个和进⾏分组：</p>
<ul>
<li><p>第⼀组：$a_1 + b_1, a_1 + b_2, a_1 + b_3,\dots ,a_1 + b_n$</p>
</li>
<li><p>第⼆组：$a_2 + b_1, a_2 + b_2, a_2 + b_3,\dots ,a_2 + b_n$</p>
</li>
<li><p>第 $n$ 组：$a_n + b_1, a_n + b_2, a_n + b_3,\dots ,a_n + b_n$</p>
</li>
</ul>
<p>由于题⽬给出的序列 $a$ 和 $b$ 都是单调不减的，我们发现每组内的 $n$ 个和也都是单调不减的。可以暴⼒⽤ $n$ 个指针维护每⼀组的最⼩值，每次取⼀个最⼩值 $O(n)$，总时间 $O(n^2)$。</p>
<p>设计状态【和，和所属的组，和在所属组中是第⼏个】。⼀开始先将每组的最⼩和的状态存储在堆中。每次取出堆中的最⼩和后，将该组的后⼀个和压⼊到堆中。执⾏ 次这样的操作，最⼩的 $n$ 个和就得到了。总时间 $O(n \log n)$。<br>为了⽅便实现，使⽤结构体表示状态，使⽤ <code>priority_queue</code> 代替堆。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum, i, j;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;j) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sum &gt; j.sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[MAXN], b[MAXN];</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;a[i] + b[<span class="number">1</span>], i, <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">top</span>().sum &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    node now = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;a[now.i] + b[now.j + <span class="number">1</span>], now.i, now.j + <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4053-JSOI2007-建筑抢修"><a href="#P4053-JSOI2007-建筑抢修" class="headerlink" title="P4053 [JSOI2007] 建筑抢修"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4053">P4053 [JSOI2007] 建筑抢修</a></h3><p>这个题状态有两个属性【修理时⻓，截⽌时刻】，可以先对截⽌时刻排序（相当于是给所有建筑定义了⼀个优先级，截⽌时间越早的肯定越要先完成）。</p>
<p>按排序后的顺序模拟修理建筑，并记录修理总时⻓。反例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">100 100</span><br><span class="line">2 101</span><br><span class="line">3 102</span><br><span class="line">按此贪⼼只能修第 1 个建筑，实际能修第 2、3 个 建筑</span><br></pre></td></tr></table></figure>

<p>如果总时⻓不超过当前建筑的截⽌时刻，那就把当前建筑加⼊到修理计划当中；</p>
<p>否则，说明必然有⼀个建筑是不能修理的，为了让后⾯的建筑修理有更多的时间，我们应该不去修理前⾯所有建筑中时⻓最⻓的那⼀个。</p>
<p>可以⽤堆来存储所有修理建筑的时⻓，加⼊修理计划——堆中插⼊元素，移除时⻓最⻓的建筑——删除堆中最⼤值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">15e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> t1, t2;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> node &amp;i, <span class="type">const</span> node &amp;j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i.t2 &lt; j.t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i].t1 &gt;&gt; a[i].t2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += a[i].t1;</span><br><span class="line">    pq.<span class="built_in">push</span>(a[i].t1);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= a[i].t2) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum -= pq.<span class="built_in">top</span>();</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/22/heap/" data-id="clr6cevby000e5shqcwy99bdk" data-title="堆" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">算法学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82/" rel="tag">杂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">算法学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%9D%82/" style="font-size: 10px;">杂</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">算法学习笔记</a> <a href="/tags/%E9%A2%98%E8%A7%A3/" style="font-size: 20px;">题解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/12/04/solution-ABC328C/">ABC328C Consecutive 题解</a>
          </li>
        
          <li>
            <a href="/2023/12/04/solution-ABC328D/">ABC328D Take ABC 题解</a>
          </li>
        
          <li>
            <a href="/2023/12/04/solution-ABC328E/">ABC328E Modulo MST 题解</a>
          </li>
        
          <li>
            <a href="/2023/12/04/solution-ABC329C/">ABC329C Count xxx 题解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 rksm2329<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>